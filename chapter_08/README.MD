# ğŸ“– Chapter 08 â€“ Compiler, Interpreter & Packages

This chapter covers **how Java runs programs** and how to organize your code using **packages**.

---

## ğŸ–¥ 1. Java Compiler & Interpreter

Java uses both a **compiler** and an **interpreter** â€“ this is why itâ€™s called a **compiled + interpreted language**.

### ğŸ”§ Process:

1. **Compilation**

   * `javac MyProgram.java` â†’ Converts `.java` file into **bytecode** (`.class` file).
   * Bytecode is **platform-independent** â€“ you can run it on any machine with JVM.

2. **Interpretation**

   * `java MyProgram` â†’ **JVM interprets bytecode** (or uses JIT compiler for faster execution) and runs it on your OS.

ğŸ“Œ **In short:**
Java is **Write Once, Run Anywhere (WORA)** because the JVM makes bytecode work on any platform.

---

## ğŸ“¦ 2. Packages

A **package** is a way to **group related classes** together.
Itâ€™s like folders on your computer â€” helps organize code, avoid name conflicts, and reuse classes.

---

### ğŸ”¹ Built-in Packages

Java already has many built-in packages:

| Package     | Purpose                              |
| ----------- | ------------------------------------ |
| `java.util` | Utility classes (Scanner, ArrayList) |
| `java.io`   | Input/Output (File handling)         |
| `java.sql`  | Database operations                  |
| `java.time` | Date & Time API                      |
| `java.net`  | Networking                           |

Example:

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter name: ");
        String name = sc.nextLine();
        System.out.println("Hello " + name);
    }
}
```

---

### ğŸ”¹ User-Defined Packages

You can **create your own package**.

---

### ğŸ›  Steps to Create & Run Package

#### **Folder Structure**

Suppose you are in `chapter_08` folder:

```
chapter_08/
 â””â”€â”€ cricket/
      â”œâ”€â”€ Virat.java
      â”œâ”€â”€ ABD.java
      â””â”€â”€ Hardik.java
```

---

### **1ï¸âƒ£ Write Classes with Package Statement**

Example â€“ `Virat.java`:

```java
package cricket;

public class Virat {
    public void stats() {
        System.out.println("Virat: 80 centuries");
    }
}
```

Similarly for `ABD.java` and `Hardik.java` (same `package cricket;` line at top).

---

### **2ï¸âƒ£ Compile Classes**

Navigate to `chapter_08` in terminal and run:

```bash
javac -d . cricket/*.java
```

âœ… **What happens?**

* `-d .` â†’ tells compiler to put `.class` files inside correct package folder.
* A new `cricket` folder will be created (inside `chapter_08` if not already present).

---

### **3ï¸âƒ£ Delete Old Package Folder Before Running Again**

ğŸ“ **IMPORTANT NOTE:**
If your folder already has `chapter_08/cricket/cricket/` (nested cricket folder), **delete the inner one** before running the above command â€” otherwise youâ€™ll get **duplicate cricket folder** (like `cricket/cricket/`) and imports will break.

---

### **4ï¸âƒ£ Create Main Class to Use Package**

`Main.java` (outside `cricket` folder):

```java
import cricket.Virat;
import cricket.ABD;

public class Main {
    public static void main(String[] args) {
        Virat v = new Virat();
        v.stats();

        ABD a = new ABD();
        a.stats();
    }
}
```

---

### **5ï¸âƒ£ Run Program**

```bash
javac Main.java
java Main
```

You should see output from both classes.

---

### ğŸ† Advantages of Packages

âœ… Better **code organization**
âœ… Avoids **name conflicts**
âœ… Easier to **maintain & reuse** code
âœ… Makes projects more **scalable**

---

## âœ… Summary

* **Java Compiler (javac)** â†’ converts source code into platform-independent bytecode.
* **JVM Interpreter** â†’ runs bytecode on any OS.
* **Packages** organize code into folders and allow reusability.
* Use `javac -d . *.java` to generate class files inside package folder.
* Delete old package folder before recompiling to avoid duplicates.